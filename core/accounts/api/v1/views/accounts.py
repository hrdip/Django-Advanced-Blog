from rest_framework import generics, status
from ..serializers.accounts import (
    RegistrationSerializer,
    CustomAuthTokenSerializer,
    CustomTokenObtainPairSerializer,
    ChangePasswordSerializer,
    ActivationResendSerializer,
    ResetPasswordSerializer,
    ResetPasswordConfirmSerializer,
    TestEmailSendSerializer,
)
from rest_framework.response import Response
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework_simplejwt.views import TokenObtainPairView
from django.contrib.auth import get_user_model
from mail_templated import EmailMessage
from ...utils import EmailThread
from rest_framework_simplejwt.tokens import RefreshToken
from django.shortcuts import get_object_or_404, redirect
import jwt
from jwt.exceptions import ExpiredSignatureError, InvalidSignatureError
from django.conf import settings

from django.contrib.sites.shortcuts import get_current_site
from django.urls import reverse_lazy


User = get_user_model()


# registration user
# use generics form customizing
class RegistrationApiView(generics.GenericAPIView):
    serializer_class = RegistrationSerializer

    def post(self, request, *args, **kwargs):
        serializer = RegistrationSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            # after serializer is valid, we get email data. in serializer we have password and email we need to show email after user registered, then we overwrite data
            email = serializer.validated_data["email"]
            data = {"email": email}
            current_site = get_current_site(self.request).domain
            # get user object
            user_obj = get_object_or_404(User, email=email)
            # generate token with simple jwt for user
            token = self.get_tokens_for_user(user_obj)
            email_obj = EmailMessage(
                "email/activation_email.tpl",
                {"token": token, "current_site": current_site},
                "admin@admin.com",
                to=[email],
            )
            # default send email
            # email_obj.send()
            # send an email with a thread for send faster
            EmailThread(email_obj).start()
            return Response(data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    # generate simple jwt for user
    def get_tokens_for_user(self, user):
        refresh = RefreshToken.for_user(user)
        return str(refresh.access_token)


# Login
# custom token authentication
# token saved on database
# because we have only the post function, we can use this class only on SWAGGER. it's not working in the API browser
class CustomObtainAuthToken(ObtainAuthToken):
    serializer_class = CustomAuthTokenSerializer

    def post(self, request, *args, **kwargs):
        # review serializer get data entry and request ( user, password , token)
        serializer = self.serializer_class(
            data=request.data, context={"request": request}
        )
        # check validation serializer
        serializer.is_valid(raise_exception=True)
        # get user
        user = serializer.validated_data["user"]
        token, created = Token.objects.get_or_create(user=user)
        return Response({"token": token.key, "user_id": user.pk, "email": user.email})


# Logout
# token saved on database
# because we have only the post function, we can use this class only on SWAGGER. it's not working in the API browser
# in APIView, serializer is not required then we user this class
class CustomDiscardAuthToken(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            token = request.user.auth_token
            token.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Token.DoesNotExist:
            return Response(
                {"detail": "Token not found."}, status=status.HTTP_400_BAD_REQUEST
            )


# jwt tokens are not saved on the database and have 3 parts; header, payload, and signature
# jwt payload, we have token_type include two section, access and refresh
# jwt payload, include user_id then we do not need to query again to find the user
# jwt payload, have expiration date, then with refresh token we can regenerate token without login user again( refresh token has expiration date too)
# jwt signature, generated by secret_key we set in settings
# jwt token is used for react front end and not used in the rendering page, rendering page usually uses session and cookies
class CustomTokenObtainPairView(TokenObtainPairView):
    serializer_class = CustomTokenObtainPairSerializer


# class to know how to send email with template
class TestEmailSend(generics.GenericAPIView):
    serializer_class = TestEmailSendSerializer

    def get(self, request, *args, **kwargs):
        # only static way to get user
        self.email = "admin@admin.com"
        # get user object
        user_obj = get_object_or_404(User, email=self.email)
        # generate token with simple jwt for user
        token = self.get_tokens_for_user(user_obj)
        # with email_obj.attach() we can attached file to email
        # with {} we send parameters
        # make email object
        email_obj = EmailMessage(
            "email/hello.tpl",
            {"token": token},
            "hrdip.2010@admin.com",
            to=[self.email],
        )
        # default send email
        # email_obj.send()
        # send an email with a thread for send faster
        EmailThread(email_obj).start()
        return Response("Email send")

    # generate simple jwt for user
    def get_tokens_for_user(self, user):
        refresh = RefreshToken.for_user(user)
        return str(refresh.access_token)


# in APIView, serializer is not required then we user this class
class ActivationApiView(APIView):
    def get(self, request, token, *args, **kwargs):
        # check validity of token
        try:
            # decode token come from email
            token = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
            # get user_id from the decoded token
            user_id = token.get("user_id")
        except ExpiredSignatureError:
            return Response(
                {"details": "token has been expired"},
                status=status.HTTP_400_BAD_REQUEST,
            )
        except InvalidSignatureError:
            return Response(
                {"details": "token is not valid"},
                status=status.HTTP_400_BAD_REQUEST,
            )
        # get user_object from user_id that gets with the decoded token
        user_obj = User.objects.get(pk=user_id)
        # check is_verified of user_object
        if user_obj.is_verified:
            return Response({"detail": "your account has already been verified"})
        # change is_verified of user to True
        user_obj.is_verified = True
        # save updated user_object
        user_obj.save()
        return Response(
            {"detail": "your account have been verified and activated successfully"}
        )


class ActivationResendApiView(generics.GenericAPIView):
    serializer_class = ActivationResendSerializer

    def post(self, request, *args, **kwargs):
        serializer = ActivationResendSerializer(data=request.data)
        # check validation serializer
        serializer.is_valid(raise_exception=True)
        # get user object come from validation serializer data
        user_obj = serializer.validated_data["user"]
        # generate token with simple jwt for user
        token = self.get_tokens_for_user(user_obj)
        email_obj = EmailMessage(
            "email/activation_email.tpl",
            {"token": token},
            "admin@admin.com",
            to=[user_obj.email],
        )
        # default send email
        # email_obj.send()
        # send an email with a thread for send faster
        EmailThread(email_obj).start()
        return Response(
            {"details": "User activation resend successfully"},
            status=status.HTTP_200_OK,
        )

    # generate simple jwt for user
    def get_tokens_for_user(self, user):
        refresh = RefreshToken.for_user(user)
        return str(refresh.access_token)


# change password
class ChangePasswordApiView(generics.GenericAPIView):
    model = User
    permission_classes = [IsAuthenticated]
    serializer_class = ChangePasswordSerializer

    # get object of user
    def get_object(self, queryset=None):
        obj = self.request.user
        return obj

    # in change password we updated the password then we must use the put function
    def put(self, request, *args, **kwargs):
        self.object = self.get_object()
        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            # check old password
            if not self.object.check_password(serializer.data.get("old_password")):
                return Response(
                    {"old_password": ["Wrong password"]},
                    status=status.HTTP_400_BAD_REQUEST,
                )
            # set_password also hashes the password that the user will get
            self.object.set_password(serializer.data.get("new_password"))
            self.object.save()
            return Response(
                {"detail": "Password Changed Successfully"},
                status=status.HTTP_200_OK,
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# API view for initiating password reset
class ResetPasswordApiView(generics.GenericAPIView):
    serializer_class = ResetPasswordSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data)
        # check validation serializer
        serializer.is_valid(raise_exception=True)
        # get user object come from validation serializer data
        user_obj = serializer.validated_data["user"]
        # generate token with simple jwt for user
        token = self.get_tokens_for_user(user_obj)
        current_site = get_current_site(self.request).domain
        email_obj = EmailMessage(
            "email/reset_password.tpl",
            {"token": token, "current_site": current_site},
            "admin@admin.com",
            to=[user_obj.email],
        )
        # default send email
        # email_obj.send()
        # send an email with a thread for send faster
        EmailThread(email_obj).start()
        return Response(
            {"details": "Reset Password send successfully"},
            status=status.HTTP_200_OK,
        )

    # generate simple jwt for user
    def get_tokens_for_user(self, user):
        refresh = RefreshToken.for_user(user)
        return str(refresh.access_token)


class ResetPasswordCheckTokenConfirmApiView(generics.GenericAPIView):
    serializer_class = ResetPasswordConfirmSerializer

    def post(self, request, token, *args, **kwargs):
        try:
            # decode token come from email
            decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
            # get user_id from the decoded token
            user_id = decoded_token.get("user_id")
        # check validation token
        except jwt.ExpiredSignatureError:
            return Response(
                {"details": "Token has expired"}, status=status.HTTP_400_BAD_REQUEST
            )
        except jwt.InvalidSignatureError:
            return Response(
                {"details": "Token is not valid"}, status=status.HTTP_400_BAD_REQUEST
            )
        except jwt.DecodeError:
            return Response(
                {"details": "Token is invalid"}, status=status.HTTP_400_BAD_REQUEST
            )
        # get user object with user_id are funded in decoded token
        user = get_object_or_404(User, pk=user_id)

        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Update user's password
        user.set_password(serializer.validated_data["new_password"])
        user.save()

        return Response(
            {"details": "Password reset successfully"}, status=status.HTTP_200_OK
        )
